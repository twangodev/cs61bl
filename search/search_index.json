{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to CS61BL Guide","text":"<p>This guide takes material from cs61bl.org and selects the most confusing yet commonly tested  aspects of the course.</p> <p>Disclaimer</p> <p>This guide is not updated, endorsed, or approved by the CS61B/CS61BL staff. Content may be outdated or incorrect.  Please refer to the official website for the most up-to-date information.</p> <p>This is not meant to replace the official website, but rather to supplement it.</p> <p>If you found this guide helpful, please consider starring the GitHub repository and sharing it with others.</p>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>If you notice that any information is incorrect, missing, or would like content removed, open an issue.</p> <p>If you would like to make changes or add your content to the guide, fork the repository and open a pull request.</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html","title":"CS61BL: Data Structures and Programming Methodology","text":""},{"location":"cheat-sheets/mt-cheat-sheet.html#by-james-ding-summer-2023-midterm-date-july-14-2023","title":"By James Ding. Summer 2023. Midterm Date: July 14, 2023.","text":""},{"location":"cheat-sheets/mt-cheat-sheet.html#java","title":"Java","text":"<p>Java is unique in that everything must be encapsulated in either a Class or Interface.</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#remember-in-java","title":"Remember, in Java:","text":"<ul> <li>When instantiating a new Object, the new keyword must be used. </li> <li>When an method returns nothing, the function return type is void</li> </ul>"},{"location":"cheat-sheets/mt-cheat-sheet.html#data-structures-and-use-cases","title":"Data Structures and Use Cases","text":""},{"location":"cheat-sheets/mt-cheat-sheet.html#arrays","title":"Arrays","text":"<p>The native way to store any type of data in an object, with a 0-index and immutable size.</p> <p>Note: To access the size of the array, use array.length</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#arraylist","title":"ArrayList <p>ArrayLists are basically dynamic arrays, in that the size is mutable. This means you can increase the size (by adding elements) without having to copy an Array Under the hood, ArrayList will automatically resize Arrays once they reach hit their size limit, or when the usage ratio is too low (to save memory)</p>  <p>Note: To Access the size of the ArrayList, use size()</p>","text":""},{"location":"cheat-sheets/mt-cheat-sheet.html#queues-and-stacks","title":"Queues and Stacks <p>Queues are like a line. You can only add to the back, and only retrieve in the front Stacks are like a stack of plates. People can only add more plates, and remote plates from the top</p>","text":""},{"location":"cheat-sheets/mt-cheat-sheet.html#trees","title":"Trees","text":""},{"location":"cheat-sheets/mt-cheat-sheet.html#binary-trees","title":"Binary Trees","text":"<p>A bushy binary tree is a tree that is perfectly balanced, in other words, each non-leaf node must have a left and right node. The opposite of this is called a spindly tree</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#binary-search-trees-bsts","title":"Binary Search Trees (BSTs)","text":"<p>A specific type of binary tree, where the left child must be smaller than the current key, and the right child must be larger than the current child</p> <p>When finding an element in a BST, check whether the node value is equal, otherwise go to the proper subtree depending on the requested item. If node is null, the node value does not exist When inserting a new element into a BST, the important aspect is that we are assigning the sub child a new tree, which is the recursive call. The base case is when null, return a new node which will be inserted When deleting a node, you want to find the smallest child of the right subtree (successor) or largest child of the left subtree (predecessor)</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#traversals","title":"Traversals <p>The following traversals will apply for Binary Trees</p>","text":""},{"location":"cheat-sheets/mt-cheat-sheet.html#depth-first-search-dfs","title":"Depth First Search (DFS)","text":"<p>Depth First Searches have a recursive nature, in which the item and children (branches) are accessed in any arbitrary order. An iterative traversal should contain a data structure such as a Stack</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#pre-order-in-order-and-post-order","title":"Pre Order, In Order, and Post Order","text":"<ul> <li>Pre: When the item is accessed first, then the left child, and finally the right child</li> <li>In: When the left child is accessed first, then the item, and finally the right child</li> <li>Post: When the left child is accessed first, then the right child, finally the item</li> </ul> <p>A special thing about traversing in-order BST will result in the original sorted order.</p> <p>Breadth First Search (BFS) For each layer, go left to right.</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#dynamic-method-selection","title":"Dynamic Method Selection","text":""},{"location":"cheat-sheets/mt-cheat-sheet.html#method-selection-process","title":"Method Selection Process","text":"<p>The diagram below should help you understand the process of method selection. The process is as follows: <pre><code>graph TD\n\n    Entry&gt;User Compiles Java Code]\n\n    CE[[Compile Error]]\n    RE[[Runtime Error]]\n\n    RD[[Run Dynamic]]\n    RLC[[Run Compiler Locked]]\n\n    subgraph Compile Time\n        Syntax(Syntax errors)\n        CCasts(Do Casts Exist)\n        ValidCCasts(Are Casts within Inhertiance)\n        Static(Does the Static Signature Exist)\n        SuperStatic(Is the Static Signature in a Superclass)\n    end\n\n    LockC{{Compiler Locks Method Signature}}\n\n\n    subgraph Run Time\n        RCasts(Do Casts Exist)\n        ValidRCasts(Do Casts Follow Inhertiance)\n\n        IsStaticMethod(Is Static-Class Method)\n\n        DynamicTypes{{Resolve Dynamic Types}}\n        ReDynamicTypes{{Override to Dynamic Superclass}}\n\n        DynamicSignatureExists(Does Dynamic Match Locked Signature)\n        SuperDynamicSignatureExists(Do Superclasses Match Locked Signature)\n    end\n\n    Entry --&gt; Syntax\n\n    Syntax -- Yes --&gt; CE\n    Syntax -- No --&gt; CCasts\n\n    CCasts -- Yes --&gt; ValidCCasts\n    ValidCCasts -- Yes --&gt; Static\n    ValidCCasts -- No --&gt; CE\n    CCasts -- No --&gt; Static\n\n    Static -- Yes --&gt; LockC\n    Static -- No --&gt; SuperStatic\n    SuperStatic -- No --&gt; CE\n    SuperStatic -- Yes --&gt; LockC\n\n    LockC --&gt; RCasts\n\n    RCasts -- Yes --&gt; ValidRCasts\n    ValidRCasts -- Yes --&gt; IsStaticMethod   \n    ValidRCasts -- No --&gt; RE\n    RCasts -- No --&gt; IsStaticMethod\n\n\n    IsStaticMethod -- Yes --&gt; RLC\n    IsStaticMethod -- No --&gt; DynamicTypes\n\n    DynamicTypes --&gt; DynamicSignatureExists\n\n\n    DynamicSignatureExists -- Yes --&gt; RD\n    DynamicSignatureExists -- No --&gt; SuperDynamicSignatureExists\n\n    SuperDynamicSignatureExists -- Yes --&gt; ReDynamicTypes\n    ReDynamicTypes --&gt; DynamicSignatureExists\n\n    SuperDynamicSignatureExists -- No --&gt; RLC</code></pre></p> <p>It is to be noted that Casting only affects the static type. The cast will become ineffective during runtime</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#asymptotic-analysis","title":"Asymptotic Analysis <p>Analyzing the runtime of any function, as some arbitrary N increases in size.</p>  <p>Fun Fact: Computers can't actually solve this problem - see Halting Problem</p>  <p>Arithmetic Sums: <code>1+2+3+4+f(N)=(f(N)2)</code></p> <p>Geometric Sum: <code>1+2+4+8+f(N)=(f(N))</code></p> <p>Recursive Last Layer Work: <code>B^W</code>, where B is the branching factor and W is the</p> <p>For anything equal to or below (2N-1), you can drop constants for it to become (2N). However, for anything equal to or bigger than (NN), constants within the exponent have a significant role</p>","text":""},{"location":"cheat-sheets/mt-cheat-sheet.html#notations","title":"Notations","text":"<p>The most popular form to describe a runtime of a function is Big-O notation, represented by O(),  being any function (listed below) that describes the general runtime of the function. Drop any constants (including the base of log - change of base reveals its actually a constant)</p> <p><code>1 &lt; log(N) &lt; N &lt; N log(N) &lt; N^2 &lt; N^C &lt; C^N &lt; N^N &lt; N!</code></p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#big-omega","title":"Big Omega","text":"<p>When it comes to Big Omega, you can think of it is a &gt; sign.</p> <p>Formal Definition: R(N)(f(N)) if and only if there exists a positive constant k1 such that R(N)k1f(N) for all N greater than some N0 (a very large N</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#big-o","title":"Big O","text":"<p>When it comes to Big O, you can think of it as a &lt; sign. Format Definition: R(N)O(f(N)) if and only if there exists a positive constant k2 such that R(N)k2f(N) for all N greater than some N0 (a very large N)</p>"},{"location":"cheat-sheets/mt-cheat-sheet.html#big-theta","title":"Big Theta","text":"<p>Exists if and only if the tightest Big Omega and Big O bound are equal (aka bounded by the same family of functions)</p>"},{"location":"concepts/oop/dynamic-method-selection.html","title":"Dynamic Method Selection","text":"<p>Dynamic method selection is the process by which a method is selected for execution at runtime based on the actual type  of object it's called on.</p> <p>This is sometimes different from than the type it's presented as during compile-time, which makes things a little  tricky.</p>"},{"location":"concepts/oop/dynamic-method-selection.html#compile-time-selection","title":"Compile Time Selection","text":""},{"location":"concepts/oop/dynamic-method-selection.html#compilers","title":"Compilers","text":"<p>Let's take a step back and understand the role of a compiler.</p> <p>A compiler is a computer program that takes code written in one programming language (the source code) and translates it into another language, typically machine code, which can be executed directly by a computer's hardware. This translation process allows the computer to understand and run the program. The compiled code is often saved as an executable file,  which can be run any number of times without needing to be compiled again.</p> <p>Where do Syntax Errors come from?</p> <p>During compilation (the process of compiling code), the compiler checks that all your code makes sense. Therefore, syntax errors or illegal references can be picked up by our compiler, and thrown as a compilation error.</p> Compiler Analogy <p>Imagine you've written a detailed recipe for a new dish you've created. You wrote it in your unique style, with shorthand notes and special symbols that only you and a few friends understand. But for a wider audience, like an international cookbook, you'd need this recipe to be in a format that many people around the world can read and understand.</p> <p>A compiler in programming is a bit like a translator for your special recipe. When you write a program (or the \"recipe\" in our analogy), you're often writing it in a high-level language that's easier for humans to read and write. But computers don't understand this high-level language directly; they understand a much simpler and more primitive language (machine code).</p> <p>So, a compiler takes your high-level program and translates (or \"compiles\") it into the low-level machine code that the computer can understand and execute. Just like converting your unique recipe into a format suitable for an international cookbook.</p> <p>This process ensures that you can write programs in a more human-friendly manner, while still allowing the computer to understand and run them.</p>"},{"location":"concepts/oop/dynamic-method-selection.html#cast-validity","title":"Cast Validity","text":"<p>If casts exist in our Java code, we need to make sure it's a valid cast within the [inheritance tree]</p>"},{"location":"concepts/oop/dynamic-method-selection.html#summary","title":"Summary","text":"<pre><code>graph TD\n\n    Entry&gt;User Compiles Java Code]\n\n    CE[[Compile Error]]\n    RE[[Runtime Error]]\n\n    RD[[Run Dynamic]]\n    RLC[[Run Compiler Locked]]\n\n    subgraph Compile Time\n        Syntax(Syntax errors)\n        CCasts(Do Casts Exist)\n        ValidCCasts(Are Casts within Inhertiance)\n        Static(Does the Static Signature Exist)\n        SuperStatic(Is the Static Signature in a Superclass)\n    end\n\n    LockC{{Compiler Locks Method Signature}}\n\n\n    subgraph Run Time\n        RCasts(Do Casts Exist)\n        ValidRCasts(Do Casts Follow Inhertiance)\n\n        IsStaticMethod(Is Static-Class Method)\n\n        DynamicTypes{{Resolve Dynamic Types}}\n        ReDynamicTypes{{Override to Dynamic Superclass}}\n\n        DynamicSignatureExists(Does Dynamic Match Locked Signature)\n        SuperDynamicSignatureExists(Do Superclasses Match Locked Signature)\n    end\n\n    Entry --&gt; Syntax\n\n    Syntax -- Yes --&gt; CE\n    Syntax -- No --&gt; CCasts\n\n    CCasts -- Yes --&gt; ValidCCasts\n    ValidCCasts -- Yes --&gt; Static\n    ValidCCasts -- No --&gt; CE\n    CCasts -- No --&gt; Static\n\n    Static -- Yes --&gt; LockC\n    Static -- No --&gt; SuperStatic\n    SuperStatic -- No --&gt; CE\n    SuperStatic -- Yes --&gt; LockC\n\n    LockC --&gt; RCasts\n\n    RCasts -- Yes --&gt; ValidRCasts\n    ValidRCasts -- Yes --&gt; IsStaticMethod   \n    ValidRCasts -- No --&gt; RE\n    RCasts -- No --&gt; IsStaticMethod\n\n\n    IsStaticMethod -- Yes --&gt; RLC\n    IsStaticMethod -- No --&gt; DynamicTypes\n\n    DynamicTypes --&gt; DynamicSignatureExists\n\n\n    DynamicSignatureExists -- Yes --&gt; RD\n    DynamicSignatureExists -- No --&gt; SuperDynamicSignatureExists\n\n    SuperDynamicSignatureExists -- Yes --&gt; ReDynamicTypes\n    ReDynamicTypes --&gt; DynamicSignatureExists\n\n    SuperDynamicSignatureExists -- No --&gt; RLC</code></pre>"},{"location":"concepts/oop/inheritance.html","title":"Inheritance","text":"<p>In programming, especially in Java, inheritance is a mechanism where a new class derives or \"inherits\" properties and behaviors (methods) from an existing class. The primary advantage is that it promotes code reusability and establishes a relationship between the parent and child classes.</p>"},{"location":"concepts/oop/inheritance.html#super-and-subclasses","title":"Super and Subclasses","text":"<pre><code>class Animal {\n    void eat() {\n        System.out.println(\"This animal eats food.\");\n    }\n}\n\nclass Dog extends Animal {\n    void bark() {\n        System.out.println(\"The dog barks.\");\n    }\n}\n</code></pre> <p>Notice how we generalize the behavior of an animal (in this case, just eating) in the <code>Animal</code> class. We then extend this class to create a <code>Dog</code> class, which inherits the <code>eat()</code> method from the <code>Animal</code> class, but also has its own <code>bark()</code> method.</p> <pre><code>Dog fido = new Dog();\nfido.eat(); // This animal eats food.\nfido.bark(); // The dog barks.\n</code></pre> <p>The superclass is the class being inherited from, and the subclass is the class that inherits from the superclass. In this case, <code>Animal</code> is the superclass, and <code>Dog</code> is the subclass.</p>"},{"location":"concepts/oop/inheritance.html#sibling-classes","title":"Sibling Classes","text":"<p>We can also create a <code>Cat</code> class, which also inherits the <code>eat()</code> method from the <code>Animal</code> class, but has its own <code>meow()</code> method.</p> <pre><code>class Cat extends Animal {\n    void meow() {\n        System.out.println(\"The cat meows.\");\n    }\n}\n</code></pre> <pre><code>Cat whiskers = new Cat();\nwhiskers.eat(); // This animal eats food.\nwhiskers.meow(); // The cat meows.\n</code></pre> <p>In this case, <code>Dog</code> and <code>Cat</code> are sibling classes, as they both inherit from the same parent class, <code>Animal</code>.</p> Can we say that Dog extends Cat or vice versa? <p>No, we cannot. Inheritance is a parent-child relationship, not a sibling relationship.</p> Can we have multiple superclasses? <p>No, we cannot. Java does not allow classes to inherit from multiple superclasses.</p>"},{"location":"concepts/oop/inheritance.html#inheritance-rules","title":"Inheritance Rules","text":""},{"location":"concepts/oop/inheritance.html#access-modifiers","title":"Access Modifiers","text":"<p>When inheriting from a superclass, the subclass can only access the superclass' public and protected members.</p> <p>This means that all private members are not accessible to the subclass.</p> <p>Example</p> <p>If we modify the <code>Animal</code> class to have a private <code>sleep()</code> method, we cannot access it from the <code>Dog</code> class.</p>"},{"location":"concepts/oop/inheritance.html#constructor-inheritance","title":"Constructor Inheritance","text":"<p>In Java, constructors are unique in that they are not members in the traditional sense and therefore cannot be  \"inherited\" as methods or attributes are. However, constructors play a role in the inheritance hierarchy through the  mechanism of constructor chaining. Here's how it works:</p>"},{"location":"concepts/oop/inheritance.html#constructor-chaining","title":"Constructor Chaining","text":"<p>When you create an instance of a derived class, its constructor is responsible for calling the constructor of its  immediate parent class. This is done using the <code>super</code> keyword.</p> <p>The constructor of the base class is always executed before the derived class's constructor. If you don't explicitly call a parent's constructor, Java will automatically call the no-argument constructor of the parent class.</p> ImplicitExplicit <p>When a child class does not provide any explicit call to the base class constructor, the compiler automatically inserts a call to the no-argument constructor of the base class using <code>super()</code>.</p> <pre><code>class Parent {\n    Parent() {\n        System.out.println(\"Parent Class Constructor\");\n    }\n}\n\nclass Child extends Parent {\n    Child() {\n        System.out.println(\"Child Class Constructor\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Child child = new Child();  \n\n        /* Output:\n        Parent Class Constructor\n        Child Class Constructor\n        */\n    }\n}\n</code></pre> <p>If the base class does not have a no-argument constructor, or if you want to call a different constructor of the base class, you need to explicitly use super with arguments.</p> <pre><code>class Parent {\n    Parent(int x) {\n        System.out.println(\"Parent Class Constructor with value \" + x);\n    }\n}\n\nclass Child extends Parent {\n    Child() {\n        super(42);  // Explicit call to Parent's constructor\n        System.out.println(\"Child Class Constructor\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Child child = new Child();         \n\n        /* Output:\n        Parent Class Constructor with value 42\n        Child Class Constructor\n        */\n    }\n}\n</code></pre> <p>Takeaways</p> <ul> <li>A call to <code>super()</code> (whether implicit or explicit) must always be the first statement in the derived class's constructor.</li> <li>If the parent has no default (no-argument) constructor, the child class must explicitly call a parent constructor using <code>super(...)</code>.</li> <li>A derived class can't inherit a parent's constructor in the traditional sense, but it does have to ensure that one of the parent's constructors is called when an object of the derived class is instantiated.</li> </ul> Concept Check <p>Consider the following code. Then answer the questions below. <pre><code>class Grandparent {\n    Grandparent() {\n        System.out.println(\"hi gramps!\");\n    }\n\n    Grandparent(int x) {\n        System.out.println(\"woah gramps is: \" + x);\n    }\n}\n\nclass Parent extends Grandparent {\n    Parent() {\n        System.out.println(\"gramps child.\");\n    }\n\n    Parent(int y) {\n        this();\n        System.out.println(\"gramps child is: \" + y);\n    }\n}\n\nclass Child extends Parent {\n    Child() {\n        super(50);\n        System.out.println(\"grandchild\");\n    }\n}\n\nclass FamilyTree {\n    public static void main(String[] args) {\n        new Child();\n    }\n}\n</code></pre></p> <p>Part 1: Is this valid Java?</p> <ul> <li> The code compiles and runs without error.</li> <li> The code compiles but throws an exception at runtime.</li> <li> The code does not compile.</li> </ul> <p>Part 2: Select the output of the program, in order (if applicable).</p> <ul> <li> hi gramps!</li> <li> woah gramps is: 50</li> <li> gramps child.</li> <li> gramps child is: 50</li> <li> grandchild</li> <li> grandchild is: 50</li> </ul> Concept Check Solution <p>The solution for Part 1</p> <ul> <li> The code compiles and runs without error.</li> <li> The code compiles but throws an exception at runtime.</li> <li> The code does not compile. </li> </ul> Wait hold up... what's <code>this()</code> then? <p>In this case, <code>this()</code> calls the no-arg constructor of the current class. This resolves to calling the  no-argument constructor of <code>Parent</code>, so it's actually completely valid.</p> <p>The solution for Part 2</p> <ul> <li> hi gramps!</li> <li> woah gramps is: 50</li> <li> gramps child.</li> <li> gramps child is: 50</li> <li> grandchild</li> <li> grandchild is: 50 </li> </ul> <p>Let's break this down.</p> <ol> <li>We start by instantiating our <code>Child</code> object. This calls the <code>Child</code> constructor.</li> <li>The <code>Child</code> constructor begins with a call to <code>super(50)</code>, which just calls <code>Parent(int y)</code>, as <code>Child</code>  extends <code>Parent</code>.<ol> <li><code>Parent(int y)</code> calls <code>this()</code>, which resolves to <code>Parent()</code>, as <code>Parent</code> extends <code>Grandparent</code>.<ol> <li><code>Parent()</code> implicitly calls <code>super()</code>, which calls <code>Grandparent()</code>.<ol> <li><code>Grandparent()</code> prints <code>hi gramps!</code>. This is the first line of output.</li> </ol> </li> <li><code>Parent()</code> prints <code>gramps child.</code>. This is the second line of output.</li> </ol> </li> <li><code>Parent(int y)</code> prints <code>gramps child is: 50</code>. This is the third line of output.</li> </ol> </li> <li><code>Child</code>'s constructor prints <code>grandchild</code>. This is the fourth line of output.</li> </ol>"},{"location":"concepts/oop/inheritance.html#method-overriding","title":"Method Overriding","text":"<p>If a child class has a method with the same name as a method in the parent class, it is known as method overriding.  The method in the child class should have the same name, return type, and parameters as the one in the parent class.</p> <p>This will be covered in more detail in Dynamic Method Selection.</p>"},{"location":"concepts/oop/inheritance.html#method-overloading","title":"Method Overloading","text":"<p>If a class has multiple methods with the same name but different parameters, it is known as method overloading. Specifically, the methods can have the same name while maintaining different function signatures.</p> <p>Example</p> <p>Let's say we have a class <code>Calculator</code> with a method <code>add</code> that takes two <code>int</code>s and returns an <code>int</code>. <pre><code>class Calculator {\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre> We can overload the <code>add</code> method to take two <code>double</code>s and return a <code>double</code>. <pre><code>class Calculator {\n    int add(int a, int b) {\n        return a + b;\n    }\n\n    double add(double a, double b) {\n        return a + b;\n    }\n}\n</code></pre> Note that the bodies of the function don't have to be the same.</p> By changing the return type, does this count as method overloading? <p>No. Method overloading is only when the method name and parameters are the same.</p>"},{"location":"concepts/oop/inheritance.html#inheritance-trees","title":"Inheritance Trees","text":"<p>We can visualize the relationship between classes using inheritance trees. It's similar to the concept of a family tree, where the parent class is the parent, and the child classes are the children.</p> <pre><code>classDiagram\n    Animal &lt;|-- Dog\n    Animal &lt;|-- Cat\n\n    class Animal {\n        +eat()\n    }\n\n    class Dog {\n        +bark()\n    }\n\n    class Cat {\n        +meow()\n    }</code></pre> <p>When we say that a class is a part of an inheritance tree, we mean the inheritance tree contains that class. For example, <code>Dog</code> is apart of the inheritance tree above, but <code>Bird</code> is not.</p> <p>Remember how inheritance lets one class (child class) \"inherit\" properties and methods from another class (parent class)? It's great for establishing an \"is-a\" relationship. For example, a Dog is an Animal.</p> <p>But what if we have behaviors that can be shared across classes that don't fit into a strict \"is-a\" relationship? For instance, both Bird and Airplane can fly, but it doesn't make sense to say an Airplane is a Bird or vice versa.</p> <p>This is where interfaces come into play!</p>"},{"location":"concepts/oop/inheritance.html#interfaces","title":"Interfaces","text":"<p>An interface is a blueprint of methods. Unlike classes, interfaces can't have any actual implementation of methods - they can only provide method declarations. This means when a class \"implements\" an interface, it promises to provide the actual behavior (implementation) for those methods.</p> <pre><code>// Interface declaration\ninterface Flyable {\n    void fly();\n}\n\n// Bird class implementing Flyable interface\nclass Bird implements Flyable {\n    @Override\n    public void fly() {\n        System.out.println(\"Bird flaps its wings to fly.\");\n    }\n}\n\n// Airplane class implementing Flyable interface\nclass Airplane implements Flyable {\n    @Override\n    public void fly() {\n        System.out.println(\"Airplane uses engines to fly.\");\n    }\n}\n</code></pre> <p>Because both Bird and Airplane are flyable, so they implement the Flyable interface and provide their unique implementation of the <code>fly()</code> method.</p> <p>But what real benefit does this provide? Well, let's say we want all of our flyable objects to take off.  <pre><code>List&lt;Flyable&gt; takeoffRoster = new ArrayList&lt;&gt;();\n\n// Add some birds and airplanes to the list\ntakeoffRoster.add(new Bird());\ntakeoffRoster.add(new Airplane());\n\n// Take off!\nfor (Flyable flyable : takeoffRoster) {\n    flyable.fly();\n}\n</code></pre></p> <p>Without interfaces, we would have to have two lists - one for birds and one for airplanes. But with interfaces, we can generalize the behavior of flying and treat all flyable objects the same.</p> Can you have a class that implements multiple interfaces? <p>Yes, you can! A class can implement multiple interfaces, but it can only extend one class.</p> <p>Takeaways</p> <ul> <li>Interfaces give flexibility, as it ensures that certain classes adhere to a certain \"contract\" without dictating how that behavior is achieved.</li> <li>Abstraction: It offers another level of abstraction, helping you segregate what a class should do (interface) from how it achieves doing it (class implementation).</li> </ul>"},{"location":"concepts/oop/inheritance.html#abstract-classes","title":"Abstract Classes","text":"<p>If we think of regular classes as blueprints for creating objects and interfaces as contracts that certain classes must adhere to, then abstract classes fall somewhere in between.</p> <p>An abstract class is a class that cannot be instantiated on its own and requires subclasses to provide implementations for its abstract methods. In essence, it's \"incomplete\" on its own.</p>"},{"location":"concepts/oop/inheritance.html#features-of-abstract-classes","title":"Features of Abstract Classes","text":"<ul> <li>You can't create an instance of an abstract class using the new keyword directly.</li> <li>Abstract classes can have both fully implemented methods (like a regular class) and abstract methods (which have no body, similar to interface methods).</li> <li>You can </li> </ul> <p>Let's use abstract classes to model relationships between vehicles. <pre><code>// Abstract class declaration\nabstract class Vehicle {\n    // An abstract method: No implementation here!\n    abstract void move();\n\n    // A regular method: With implementation.\n    void fuelUp() {\n        System.out.println(\"The vehicle is fueled up!\");\n    }\n}\n\n// A subclass implementing the abstract method\nclass Car extends Vehicle {\n    @Override\n    void move() {\n        System.out.println(\"The car moves on four wheels.\");\n    }\n}\n\n// Another subclass implementing the abstract method\nclass Boat extends Vehicle {\n    @Override\n    void move() {\n        System.out.println(\"The boat sails on water.\");\n    }\n}\n</code></pre></p> <p>Here, every Vehicle can fuel up, but the way each vehicle moves is different and specific to the subclass. We can still override the <code>fuelUp()</code> method in the subclass if we want to.</p> <pre><code>class Tesla extends Car {\n    @Override\n    void fuelUp() {\n        System.out.println(\"The Tesla is charged up!\");\n    }\n}\n</code></pre> <p>Takeaways</p> <ul> <li>If multiple subclasses should implement some methods in the same way (shared behavior), this common implementation can be provided in the abstract class itself.</li> <li>Like interfaces, any class that extends an abstract class is forced to implement its abstract methods. This  ensures a certain structure among subclasses.</li> <li>Unlike interfaces, abstract classes can have member variables that are not public, static, and final, allowing for  more flexible data storage capabilities.</li> <li>Abstract classes can have constructors, even though they can't be instantiated! This is useful because a subclass  can call this constructor to set up initial state or perform validations.</li> </ul>"},{"location":"data-structures/trees/binary-search-trees.html","title":"Binary Search Trees (BSTs)","text":"<p>A binary search tree is a type of binary tree which follows the BST Property.</p>"},{"location":"data-structures/trees/binary-search-trees.html#bst-property","title":"BST Property","text":"<p>For every node $N$ in a BST, the following conditions are true:</p> <ul> <li>Every item in $N$'s left subtree is less than $N$.</li> <li>Every item in $N$'s right subtree is greater than $N$.</li> </ul> <pre><code>graph TD\n    A(5) --&gt; B(3)\n    A --&gt; C(7)\n    B --&gt; D(2)\n    B --&gt; E(4)\n    C --&gt; F(6)\n    C --&gt; G(8)</code></pre> <p>Tip</p> <p>Within CS61BL, BSTs will have unique keys. Therefore, given keys $K_1$ and $K_2$, $K_1 &lt; K_2$ or $K_1 &gt; K_2$.</p> <p>Consequently, given $K_3$, if $K_3 &lt; K_1$, then $K_3$ must be in $K_1$'s left subtree. If $K_3 &gt; K_1$, then $K_3$ must be in $K_1$'s right subtree. (assuming $K_1$ is the parent)</p> <p>The transitive property of inequality can be used to extend this to any node in the tree.</p>"},{"location":"data-structures/trees/binary-search-trees.html#searching","title":"Searching","text":"<p>In order to search for a key $K$ in a BST, we can use the BST property to our advantage.</p> <p>In Python, we can implement this as follows:</p> <pre><code>def search(root, key):\n    if root is None or root.key == key:\n        return root\n    if root.key &lt; key:\n        return search(root.right, key)\n    return search(root.left, key)\n</code></pre>"},{"location":"data-structures/trees/binary-search-trees.html#time-complexity","title":"Time Complexity","text":"<p>The time complexity of searching for a key $K$ of size $N$ in a BST is $\\Theta(\\log N)$ in the best case, and $\\Theta(N)$ in the worst case.</p>"},{"location":"data-structures/trees/binary-search-trees.html#best-case","title":"Best Case","text":"<p>The best case occurs when the tree is bushy, or balanced. This means that for each node, there are roughly the same number of nodes in the left and right subtrees. This produces a tree with $\\log N$ levels, where $N$ is the number of nodes in the tree.</p> <p>Example</p> <pre><code>graph TD\n    A(5) --&gt; B(3)\n    A --&gt; C(7)\n    B --&gt; D(2)\n    B --&gt; E(4)\n    C --&gt; F(6)\n    C --&gt; G(8)</code></pre>"},{"location":"data-structures/trees/binary-search-trees.html#worst-case","title":"Worst Case","text":"<p>Conversely, the worst case occurs when the tree is \"spindly\", or unbalanced. This means that for each node, there are many more nodes in one subtree than the other. This produces a tree with $N$ levels, where $N$ is the number of nodes in the tree.</p> <p>Example</p> <p><pre><code>graph LR\n    A(1) --&gt; B(2)\n    B --&gt; C(3)\n    C --&gt; D(4)</code></pre> This depiction of the \"tree\" essentially represents a linked list, which has a time complexity of $\\Theta(N)$.</p>"},{"location":"data-structures/trees/binary-search-trees.html#insertion","title":"Insertion","text":"<p>In order to insert a key $K$ into a BST, we can use the BST property to our advantage, similar to searching.</p> <p>In Python, we can implement this as follows:</p> <p><pre><code>def insert(root, key):\n    if root is None:\n        return Node(key)\n    if root.key &lt; key:\n        root.right = insert(root.right, key)\n    else:\n        root.left = insert(root.left, key)\n    return root\n</code></pre> We essentially search for the key $K$ in the tree, which is when we reach a <code>None</code> node. Note that the parent of this node is the node that we want to insert $K$ into. We then create a new node with key $K$ and return it.</p>"},{"location":"data-structures/trees/binary-search-trees.html#deletion","title":"Deletion","text":"<p>Deletion is slightly more tricky than insertion and searching, as we need to consider the following cases:</p>"},{"location":"data-structures/trees/binary-search-trees.html#deletion-of-a-leaf","title":"Deletion of a Leaf","text":"<p>If the node to be deleted is a leaf, we can simply delete it, as it has no \"dependants\".</p>"},{"location":"data-structures/trees/binary-search-trees.html#deletion-of-a-node-with-one-child","title":"Deletion of a Node with One Child","text":"<p>If the node $K$ to be deleted has one child, we can simply replace $K$ with its child. In essence, we are \"promoting\" the child to take the place of $K$.</p>"},{"location":"data-structures/trees/binary-search-trees.html#deletion-of-a-node-with-two-children-hibbard-deletion","title":"Deletion of a Node with Two Children (Hibbard Deletion)","text":"<p>If the node $K$ to be deleted has two children, we need to find the successor of such that BST Property is maintained.</p> <p>The successor of node $K$ is the greatest leaf in $K$'s left subtree or the smallest leaf in $K$'s right subtree.</p> <p>After a successor is found, the successor is swapped with $K$, and $K$ is deleted.</p>"},{"location":"data-structures/trees/binary-trees.html","title":"Binary Trees","text":"<p>Binary trees are a specific type of rooted trees where each node has at most two children (subtrees).</p> <pre><code>graph TD\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F</code></pre>"},{"location":"data-structures/trees/binary-trees.html#conditions-for-binary-trees","title":"Conditions for Binary Trees","text":"<ul> <li>Every node $N$ in a binary tree has exactly one parent.</li> <li>Every node $N$ in a binary tree has at most two children, but can have 0.</li> </ul> <p>Tip</p> <p>Binary trees are depicted as \"upside-down\" trees, with the root at the top and leaves on the bottom.</p>"},{"location":"data-structures/trees/left-leaning-red-black-trees.html","title":"Left Leaning Red Black Trees (LLRBs)","text":""},{"location":"data-structures/trees/left-leaning-red-black-trees.html#2-3-trees","title":"2-3 Trees","text":"<p>Before starting with LLRBs, we must first understand 2-3 trees.</p> <p> In a binary tree, a single node must have one key, similar to a LinkedList. To prevent our BST from becoming a  spindly, we can allow each node to have at most two keys, and three children. This implementation is guarantees a  self-balancing tree.</p>"},{"location":"data-structures/trees/left-leaning-red-black-trees.html#searching","title":"Searching","text":"<p>Searching for a key $K$ in a 2-3 tree is similar to searching for a key in a BST. However, we must now consider the case  where a node has two keys.</p> <p>When a node has two keys, we must check if $K$ is less than the first key, between the first and second key, or greater than the second key. This will determine which subtree we search next.</p> <p>In Python, we can implement this as follows:</p> <pre><code>def search(root, key):\n    if root is None or root.key1 == key or root.key2 == key:\n        return root\n    if root.key1 &gt; key:\n        return search(root.left, key)\n    if root.key2 is None or root.key2 &gt; key:\n        return search(root.middle, key)\n    return search(root.right, key)\n</code></pre> <p>The overall runtime of searching for a key $K$ of size $N$ in a 2-3 tree is $O(\\log N)$</p>"},{"location":"data-structures/trees/left-leaning-red-black-trees.html#insertion","title":"Insertion","text":"<p>When inserting a key $K$ into a 2-3 tree, we first identify which node $N$ and parent $P$ to insert $K$ into.</p>"},{"location":"data-structures/trees/left-leaning-red-black-trees.html#basic-insertion-single-keyed-node","title":"Basic Insertion (Single-Keyed Node)","text":"<p>If $N$ has only one key, we can simply insert $K$ into $N$.</p> <p>The final result will result in $N$ having two keys.</p> Visual Walkthrough <p> The following is an result of inserting 8 into a 2-3 tree.</p> <p>We first check for where 8 should be inserted. Since 8 falls between 5 and 9, we select the middle node of the tree. Since the middle node has only one key, we can insert 8 into the middle node, following the Basic Insertion rule.</p>"},{"location":"data-structures/trees/left-leaning-red-black-trees.html#push-up-insertion-single-keyed-parent","title":"Push Up Insertion (Single-Keyed Parent)","text":"<p>However, if $N$ already has two keys $K_1$, $K_2$ and $P$ has one key $P_K$, we need to temporarily overstuff $N$ by inserting $K$ into $N$. This  will result in $N$ having three keys, $K_1$, $K_2$, and $K_3$</p> <p>Next, we split our overstuffed node - essentially destroying the node and creating individual nodes $N_1$, $N_2$, $N_3$ for each key.</p> <p>This sometimes will end up with an unbalanced tree (each leaf may be at a different height), which violates the core idea of having a self-balancing tree. Instead, we can take the middle node $N_2$ and add it's key it into our parent  node $P$. $N_1$ becomes the left node of $P$ and $N_3$ now becomes the center node of our parent $P$. The end result should be our parent $P$ having keys $P_{K_1}$, $P_{K_2}$ and nodes $N_1$, $N_3$, $N$</p> Visual Walkthrough <p> The following tree on the right is the result of overstuffing 4 into a 2-3 tree.</p> <p>We first check for where 4 should be inserted. Since 4 is less than 5, and greater than 1 and 3, we overstuff our 1 3 node by adding 4.</p> <p> Next, we split our overstuffed node. We destroy the original overstuffed node, then create individual nodes for each key that was apart of the destroyed node.</p> <p>Note that this example's tree isn't balanced, so unfortunately we'll have to go onto the next step. However, if the overstuffed node was our root node, our tree would be considered balanced.</p>"},{"location":"data-structures/trees/left-leaning-red-black-trees.html#push-up-insertion-double-keyed-parent","title":"Push Up Insertion (Double-Keyed Parent)","text":"<p>If $N$ already has two keys, $K_1$, $K_2$ and $P$ has two keys $P_{K_1}$, $P_{K_2}$, we need to temporarily overstuff $N$ by inserting $K$ into $N$. This will result in $N$ having three keys, $K_1$, $K_2$, and $K_3$</p> <p>Next, we push $K_2$ into our parent node $P$. This will result in $P$ not only being overstuffed, but also containing 4 children.</p> <p>Next, we split our overstuffed $P$ node - essentially destroying the node and creating individual nodes $N_1$, $N_2$, $N_3$ for each of its keys $P_{K_1}$, $P_{K_2}$, $P_{K_3}$. This leaves us with $N_1$ and $N_3$ as our left and right nodes, respectively, and $N_2$ as our center node. It's children follow $N_1$ and $N_3$'s accordingly.</p>"},{"location":"data-structures/trees/left-leaning-red-black-trees.html#insertion-summary","title":"Insertion Summary","text":"<p>The result gives us an insertion which takes $O(\\log N)$ time, where $N$ is the number of nodes in the tree.</p>"},{"location":"data-structures/trees/left-leaning-red-black-trees.html#left-leaning-red-black-trees","title":"Left Leaning Red Black Trees","text":""},{"location":"exam-prep/topical-resources.html","title":"Topical Resources","text":"<p>This page contains a list of resources for each topic in the course. These resources are not exhaustive, and are intended to be used as a starting point for your review.</p>"},{"location":"exam-prep/topical-resources.html#sorting","title":"Sorting","text":"Practice ProblemsExam QuestionsExam Solutions"},{"location":"exam-prep/topical-resources.html#graphs","title":"Graphs","text":"Practice ProblemsExam QuestionsExam Solutions"},{"location":"exam-prep/topical-resources.html#union-find","title":"Union Find","text":"Practice ProblemsExam QuestionsExam Solutions"},{"location":"exam-prep/topical-resources.html#heaps","title":"Heaps","text":"Practice ProblemsExam QuestionsExam Solutions"},{"location":"exam-prep/topical-resources.html#hashing","title":"Hashing","text":"Practice ProblemsExam QuestionsExam Solutions"},{"location":"exam-prep/topical-resources.html#asymptotics","title":"Asymptotics","text":"Practice ProblemsExam QuestionsExam Solutions"},{"location":"exam-prep/topical-resources.html#dynamic-method-selection","title":"Dynamic Method Selection","text":"Practice ProblemsExam QuestionsExam Solutions"},{"location":"exam-prep/topical-resources.html#object-oriented-programming","title":"Object Oriented Programming","text":"Practice ProblemsExam QuestionsExam Solutions"},{"location":"exam-prep/topical-resources.html#abstract-data-types","title":"Abstract Data Types","text":"Practice ProblemsExam QuestionsExam Solutions"},{"location":"sorting/characteristics.html","title":"Sorting Characteristics","text":""},{"location":"sorting/characteristics.html#stability","title":"Stability","text":"<p>A sorting algorithm is said to be stable if it preserves the order of elements given in the unsorted list.</p>"},{"location":"sorting/characteristics.html#in-place","title":"In-Place","text":"<p>A sorting algorithm is said to be in-place if it does not require any extra memory - i.e it does not create any new arrays.</p>"},{"location":"sorting/insertion-sort.html","title":"Insertion Sort","text":"<p>Insertion sort's main concept is to iterate through the array, and for each element, insert it into the correct position in the sorted subarray.</p>"},{"location":"sorting/insertion-sort.html#implementation","title":"Implementation","text":"PseudocodePython <p>In Pseudocode, we can implement this as follows:</p> <pre><code>insertionSort(list) {\nfor each element in the list:\n    while the current element is less than the previous element:\n        swap the current element and the previous element\n}\n</code></pre> <p>In Python, we can implement this as follows:</p> <pre><code>def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        j = i\n        while j &gt; 0 and arr[j] &lt; arr[j - 1]:\n            arr[j], arr[j - 1] = arr[j - 1], arr[j]\n            j -= 1\n</code></pre>"},{"location":"sorting/insertion-sort.html#runtime-analysis","title":"Runtime Analysis","text":"<p>In order to analyze the runtime of insertion sort, we need to consider the number of elements in the array, $N$ and the number of inversion pairs, $K$.</p> <p>Because insertion sort iterates through every element in the list, insertion sort must do a minimum of $\\Theta(N)$ work. If there are inversion pairs, insertion sort must swap elements, which takes $\\Theta(1)$ time. This mean for all inversion pairs, insertion sort must do $\\Theta(K)$ work.</p> <p>Therefore, the runtime of insertion sort is $\\Theta(N + K)$.</p>"},{"location":"sorting/insertion-sort.html#best-case","title":"Best Case","text":"<p>The best case occurs when the array is already sorted. In this case, we do not need to swap any elements, and the runtime is $\\Theta(N)$.</p>"},{"location":"sorting/insertion-sort.html#worst-case","title":"Worst Case","text":"<p>The worst case occurs when the array is sorted in reverse order. In this case, we need to swap every element with the previous element, and the runtime is $\\Theta(N^2)$.</p>"}]}